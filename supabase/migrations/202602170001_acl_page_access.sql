create table if not exists public.crm_pages (
  key text primary key,
  path text not null unique,
  label text not null,
  sort_order integer not null default 0,
  is_active boolean not null default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

create table if not exists public.crm_user_page_access (
  id bigint generated by default as identity primary key,
  id_usuario bigint not null,
  id_organizacao uuid not null,
  page_key text not null,
  allow boolean not null,
  created_by bigint null,
  updated_by bigint null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  constraint crm_user_page_access_user_page_unique unique (id_usuario, page_key),
  constraint crm_user_page_access_id_usuario_fkey foreign key (id_usuario) references public.usuarios (id) on delete cascade,
  constraint crm_user_page_access_id_organizacao_fkey foreign key (id_organizacao) references public.organizacao (id) on delete cascade,
  constraint crm_user_page_access_page_key_fkey foreign key (page_key) references public.crm_pages (key) on delete cascade
);

create index if not exists idx_crm_user_page_access_id_usuario
  on public.crm_user_page_access (id_usuario);

create index if not exists idx_crm_user_page_access_id_organizacao
  on public.crm_user_page_access (id_organizacao);

create index if not exists idx_crm_user_page_access_page_key
  on public.crm_user_page_access (page_key);

create index if not exists idx_crm_user_page_access_org_user
  on public.crm_user_page_access (id_organizacao, id_usuario);

create or replace function public.crm_touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_crm_pages_touch_updated_at on public.crm_pages;
create trigger trg_crm_pages_touch_updated_at
before update on public.crm_pages
for each row execute function public.crm_touch_updated_at();

drop trigger if exists trg_crm_user_page_access_touch_updated_at on public.crm_user_page_access;
create trigger trg_crm_user_page_access_touch_updated_at
before update on public.crm_user_page_access
for each row execute function public.crm_touch_updated_at();

insert into public.crm_pages (key, path, label, sort_order, is_active)
values
  ('dashboard', '/dashboard', 'Dashboard', 10, true),
  ('campanhas', '/campanhas', 'Campanhas', 20, true),
  ('clientes', '/clientes', 'Clientes', 30, true),
  ('empresas', '/empresas', 'Empresas', 40, true),
  ('pedido', '/pedido', 'Pedidos', 50, true),
  ('usuarios', '/usuarios', 'Usuarios', 60, true),
  ('agenda', '/agenda', 'Agenda', 70, true),
  ('solicitacao-portal', '/solicitacao-portal', 'Solicitacoes', 80, true),
  ('mix-sementes', '/mix-sementes', 'Mix de sementes', 90, true),
  ('verde-score', '/verde-score', 'Verde Score', 100, true),
  ('invoice', '/invoice', 'Invoice', 110, true),
  ('gestao-acessos', '/gestao-acessos', 'Gestao de acessos', 120, true)
on conflict (key) do update
set
  path = excluded.path,
  label = excluded.label,
  sort_order = excluded.sort_order,
  is_active = excluded.is_active,
  updated_at = now();

create or replace function public.crm_can_access_path(p_path text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user_id bigint;
  v_org_id uuid;
  v_role text;
  v_normalized_path text;
  v_page_key text;
  v_override_allow boolean;
begin
  if auth.uid() is null then
    return false;
  end if;

  select
    u.id,
    u.id_organizacao,
    lower(trim(coalesce(u.tipo_acesso, u.tipo_acesso_2, '')))
  into
    v_user_id,
    v_org_id,
    v_role
  from public.usuarios u
  where u.uuid_user = auth.uid()
  order by u.id desc
  limit 1;

  if v_user_id is null then
    return true;
  end if;

  v_normalized_path := coalesce(trim(p_path), '/');

  if v_normalized_path = '' then
    v_normalized_path := '/';
  end if;

  if left(v_normalized_path, 1) <> '/' then
    v_normalized_path := '/' || v_normalized_path;
  end if;

  if char_length(v_normalized_path) > 1 and right(v_normalized_path, 1) = '/' then
    v_normalized_path := left(v_normalized_path, char_length(v_normalized_path) - 1);
  end if;

  select p.key
  into v_page_key
  from public.crm_pages p
  where p.is_active = true
    and (
      p.path = v_normalized_path
      or v_normalized_path like p.path || '/%'
    )
  order by char_length(p.path) desc
  limit 1;

  if v_page_key is null then
    return true;
  end if;

  if v_page_key = 'gestao-acessos'
     and coalesce(v_role, '') not in ('gestor', 'superadm', 'superadmin', 'admin') then
    return false;
  end if;

  select a.allow
  into v_override_allow
  from public.crm_user_page_access a
  where a.id_usuario = v_user_id
    and a.page_key = v_page_key
    and (v_org_id is null or a.id_organizacao = v_org_id)
  order by a.updated_at desc, a.id desc
  limit 1;

  if v_override_allow is null then
    return true;
  end if;

  return v_override_allow;
exception
  when undefined_table then
    return true;
  when undefined_function then
    return true;
  when others then
    return true;
end;
$$;

grant execute on function public.crm_can_access_path(text) to anon, authenticated, service_role;
